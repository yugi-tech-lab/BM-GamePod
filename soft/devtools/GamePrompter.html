<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>シューティングを作ろう！</title>
  <style>
    :root{
      --accent:#2b7cff;
      --bg:#eaf6ff;
      --line:#e5e5e5;
      --soft:#f3f7ff;
      --ok:#27b35b;
      --warn:#ff4d6d;
      --text:#111;
      --muted:#555;
    }
    body{
      font-family: system-ui,-apple-system,"Hiragino Maru Gothic ProN","Yu Gothic",sans-serif;
      margin: 14px;
      background: var(--bg);
      color: var(--text);
    }

    .pageTitle{
      margin: 6px 0 12px;
      text-align:center;
      font-weight: 1000;
      font-size: 34px;
      line-height: 1.15;
      letter-spacing: .02em;
      color:#0f3a6a;
      text-shadow: 0 2px 0 rgba(255,255,255,0.8);
    }

    .box{
      border:2px solid var(--line);
      border-radius: 16px;
      padding: 16px;
      margin-bottom: 14px;
      background:#fff;
    }
    .topline{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      margin-bottom: 10px;
    }
    .progress{
      font-weight: 900;
      font-size: 18px;
      color: var(--muted);
      background:#fff;
      border:2px solid var(--line);
      padding: 6px 12px;
      border-radius: 999px;
    }
    .qtitle{
      font-size: 28px;
      font-weight: 1000;
      margin: 0 0 8px;
      line-height: 1.2;
    }
    .desc{
      font-size: 19px;
      color: var(--muted);
      margin: 0 0 14px;
      line-height: 1.55;
    }
    .desc b{ color:#111; }

    .opts{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    .opt{
      border: 3px solid var(--line);
      border-radius: 16px;
      padding: 12px;
      cursor: pointer;
      user-select:none;
      background:#fff;
      display:flex;
      gap: 12px;
      align-items:stretch;
    }
    .opt:hover{ background: var(--soft); border-color:#cfe0ff; }
    .opt.sel{ border-color: var(--accent); background: var(--soft); }

    .demoBox{
      width: 170px;
      min-width: 170px;
      height: 86px;
      border-radius: 14px;
      border: 2px solid var(--line);
      background: #fff;
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
    }
    canvas.demo{
      width: 160px;
      height: 76px;
      image-rendering: pixelated;
    }

    .textBox{ flex:1 1 auto; }
    .optMain{
      font-weight: 1000;
      font-size: 22px;
      line-height: 1.2;
    }
    .optSub{
      margin-top: 6px;
      font-size: 17px;
      color: var(--muted);
      line-height: 1.45;
      font-weight: 700;
    }

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top: 14px;
      align-items:center;
    }
    button{
      border:none;
      border-radius: 14px;
      padding: 14px 16px;
      font-weight: 1000;
      font-size: 18px;
      cursor:pointer;
    }
    .primary{ background: var(--accent); color:#fff; }
    .good{ background: var(--ok); color:#fff; }
    .dark{ background:#333; color:#fff; }
    .warn{ background: var(--warn); color:#fff; }
    button:disabled{ opacity:.45; cursor:not-allowed; }

    .checkPill{
      display:flex;
      align-items:center;
      gap:10px;
      border:2px solid var(--line);
      border-radius: 999px;
      padding: 10px 12px;
      background:#fff;
      font-weight: 1000;
      font-size: 14px;
      user-select:none;
      cursor:pointer;
    }
    .checkPill input{ transform: scale(1.25); }
    .checkPill .hint{
      font-size: 12px;
      color: var(--muted);
      font-weight: 700;
      margin-left: 6px;
      white-space: nowrap;
    }

    textarea{
      width:100%;
      box-sizing:border-box;
      border:2px solid var(--line);
      border-radius: 16px;
      padding: 14px;
      min-height: 260px;
      font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;
      font-size: 13px;
      line-height: 1.45;
    }
    .small{
      font-size: 12px;
      color: var(--muted);
      margin-top: 8px;
      line-height: 1.4;
    }
    .fullRow button{ width:100%; }

    @media (max-width: 520px){
      .pageTitle{ font-size: 30px; }
      .opt{ flex-direction: column; }
      .demoBox{ width: 100%; min-width: 0; height: 96px; }
      canvas.demo{ width: 100%; height: 86px; }
      .checkPill{ width: 100%; justify-content:center; }
    }
  </style>
<style>
  /* --- GitHub Pages mini box --- */
  #ghPagesBox{
    position: fixed;
    right: 12px;
    bottom: 12px;
    z-index: 9999;
    background: rgba(255,255,255,0.92);
    border: 1px solid rgba(0,0,0,0.15);
    border-radius: 12px;
    padding: 10px 12px;
    font-size: 12px;
    line-height: 1.4;
    box-shadow: 0 6px 18px rgba(0,0,0,0.12);
    backdrop-filter: blur(6px);
  }
  #ghPagesBox a{ color: inherit; text-decoration: underline; }
  #ghPagesBox button{
    font-size: 12px;
    padding: 4px 8px;
    border-radius: 10px;
    border: 1px solid rgba(0,0,0,0.2);
    background: white;
    cursor: pointer;
  }
  #ghPagesBox .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  #ghPagesBox .muted{ opacity:0.75; }
  #ghPagesBox .hide{ display:none; }
</style>
</head>
<body>

<div class="pageTitle">シューティングを作ろう！</div>

<div class="box" id="qBox">
  <div class="topline">
    <div class="progress" id="prog">1 / 4</div>
  </div>

  <div class="qtitle" id="qTitle"></div>
  <div class="desc" id="qDesc"></div>
  <div class="opts" id="opts"></div>

  <div class="row">
    <button class="dark" id="backBtn">まえ</button>
    <button class="primary" id="nextBtn">つぎ</button>
    <button class="warn" id="resetBtn">やりなおし</button>

    <!-- ★追加：やりなおしの右側 -->
    <label class="checkPill" title="プレイヤーを20×20ドット絵で描画（drawBitmap使用）">
      <input type="checkbox" id="dotPlayer" />
      <span>ドット絵あり</span>
      <span class="hint">20×20 / drawBitmap</span>
    </label>
  </div>

  <div class="row fullRow">
    <button class="good" id="doneBtn" style="display:none;">できあがり</button>
  </div>

  <div class="row fullRow">
    <button class="primary" id="askBtn" disabled>AIにおねがいする</button>
  </div>

  <div class="small">
    ※ゲーム種別は<b>シューティング固定</b>です。<br>
    ※ハード固定：タクト D5/D6（INPUT_PULLUP想定）、ブザー D9（ノンブロッキング）。<br>
    ※背景は<b>白</b>にしてください（OLEDはclearDisplay相当＋白背景想定の描画）。<br>
    ※送信先PCは config.js の PC_URL を編集してください。<br>
  </div>
</div>

<div class="box" id="outBox">
  <div class="row" style="margin-top:0;">
    <button class="good" id="copyBtn" disabled>プロンプトをコピー</button>
  </div>
  <textarea id="out" readonly placeholder="ここにプロンプトが出ます"></textarea>
  <div class="small" id="status"></div>
</div>

<script src="./config.js"></script>

<script>
function getPCUrl(){
  if (typeof PC_URL === "string" && PC_URL.trim()) return PC_URL.trim();
  return "";
}
const $ = (s)=>document.querySelector(s);

/* =========================
 *  state
 * ========================= */
const state = {
  style: "",
  ss_move: "",
  ss_fire: "",
  ss_goal: "",
  bb_control: "",
  bb_bricks: "",
  bb_goal: "",
  dotPlayer: false
};

let promptReady = false;
let lastPrompt = "";

/* =========================
 *  STEPS
 * ========================= */
const STEP_STYLE = {
  key:"style",
  title:"① シューティングの かたち",
  desc:
    "ゲームの種類は <b>シューティング固定</b> だよ。<br>" +
    "まずは「遊び方の形」をえらぼう！",
  options:[
    {k:"SIDE_SCROLL", label:"横スクロール", sub:"右から敵が来る！よけて撃つ。", demo:"style_side"},
    {k:"BLOCK_BREAK", label:"ブロック崩し", sub:"弾でブロックを壊す！コンボで高得点。", demo:"style_block"},
  ]
};

const STEPS_SIDE = [
  {
    key:"ss_move",
    title:"② うごき かた（横スク）",
    desc:"自機の動き方をえらぼう（D5/D6の2ボタンで成立）。",
    options:[
      {k:"SS_FLAPPY", label:"フラッピー式（D5で上昇）", sub:"D5を押すと上へ。離すと落下。D6でショット。", demo:"ss_move_flappy"},
      {k:"SS_STEP",   label:"ステップ式（D5で上下）",   sub:"D5を押すたびに上下へ1マス。D6でショット。", demo:"ss_move_step"},
    ]
  },
  {
    key:"ss_fire",
    title:"③ ショット（横スク）",
    desc:"ショットの出し方をえらぼう（D6）。",
    options:[
      {k:"SS_TAP",  label:"押すたびに1発", sub:"D6を押すと1発。連射は短い間隔で連打。", demo:"ss_fire_tap"},
      {k:"SS_HOLD", label:"長押しで連射", sub:"D6短押し=1発 / D6長押し=連射。", demo:"ss_fire_hold"},
    ]
  },
  {
    key:"ss_goal",
    title:"④ ゴール（横スク）",
    desc:"ゲームの目的をえらぼう。",
    options:[
      {k:"SS_SURVIVE", label:"生きのこり（時間）", sub:"一定時間生き残れたらクリア。", demo:"ss_goal_time"},
      {k:"SS_SCORE",   label:"スコアアタック",       sub:"制限時間でスコアをどこまで伸ばすか。", demo:"ss_goal_score"},
      {k:"SS_BOSS",    label:"ボスをたおす",         sub:"一定時間でボス出現→倒したらクリア。", demo:"ss_goal_boss"},
    ]
  }
];

const STEPS_BLOCK = [
  {
    key:"bb_control",
    title:"② 操作（ブロック）",
    desc:"2ボタン（D5/D6）で「移動」と「撃つ」を両立する方法をえらぼう。",
    options:[
      {k:"BB_LR_AUTO",     label:"D5=左 / D6=右（自動連射）", sub:"左右移動に専念。ショットは自動で一定間隔。", demo:"bb_ctrl_lr_auto"},
      {k:"BB_TOGGLE_SHOT", label:"D5=移動（方向反転）/ D6=ショット", sub:"D5押すたびに左右が反転。D6で撃つ。", demo:"bb_ctrl_toggle_shot"},
    ]
  },
  {
    key:"bb_bricks",
    title:"③ ブロックの しゅるい",
    desc:"ブロックの種類をえらぼう。",
    options:[
      {k:"BB_SIMPLE",  label:"ぜんぶ1発でこわれる", sub:"テンポよく壊せる。", demo:"bb_brk_simple"},
      {k:"BB_HP2",     label:"かたいブロックあり（2発）", sub:"2回当てないと壊れないブロックを混ぜる。", demo:"bb_brk_hp2"},
      {k:"BB_SPECIAL", label:"特殊ブロックあり", sub:"当てるとスコアUPや連射UPなどの効果。", demo:"bb_brk_special"},
    ]
  },
  {
    key:"bb_goal",
    title:"④ ゴール（ブロック）",
    desc:"クリア条件/遊び方をえらぼう。",
    options:[
      {k:"BB_ALL",   label:"全消しでクリア", sub:"ブロックを全部壊したらクリア。", demo:"bb_goal_all"},
      {k:"BB_TIME",  label:"タイムアタック", sub:"一定時間でどれだけ壊せるか。", demo:"bb_goal_time"},
      {k:"BB_COMBO", label:"コンボ重視", sub:"連続破壊で倍率UP。途切れると倍率リセット。", demo:"bb_goal_combo"},
    ]
  }
];

function getSteps(){
  if(!state.style) return [STEP_STYLE];
  if(state.style === "SIDE_SCROLL") return [STEP_STYLE, ...STEPS_SIDE];
  return [STEP_STYLE, ...STEPS_BLOCK];
}

/* =========================
 *  humanize
 * ========================= */
function styleHuman(k){
  if(k==="SIDE_SCROLL") return "横スクロール・シューティング";
  if(k==="BLOCK_BREAK") return "ブロック崩し型シューティング";
  return k;
}
function sideMoveHuman(k){
  if(k==="SS_FLAPPY") return "フラッピー式：D5で上昇、離すと落下（D6でショット）";
  if(k==="SS_STEP")   return "ステップ式：D5押下で上下1マス移動（D6でショット）";
  return k;
}
function sideFireHuman(k){
  if(k==="SS_TAP")  return "D6短押しで1発（連射は連打）";
  if(k==="SS_HOLD") return "D6短押し=1発 / D6長押し=連射";
  return k;
}
function sideGoalHuman(k){
  if(k==="SS_SURVIVE") return "生きのこり：一定時間生存でクリア（接触/被弾でミス）";
  if(k==="SS_SCORE")   return "スコアアタック：制限時間でスコア最大化";
  if(k==="SS_BOSS")    return "ボス戦：一定時間でボス出現→撃破でクリア";
  return k;
}
function blockControlHuman(k){
  if(k==="BB_LR_AUTO") return "D5=左 / D6=右（ショットは自動連射）";
  if(k==="BB_TOGGLE_SHOT") return "D5=移動（左右方向反転）/ D6=ショット";
  return k;
}
function blockBricksHuman(k){
  if(k==="BB_SIMPLE")  return "全て1発破壊";
  if(k==="BB_HP2")     return "硬いブロック混在（2発）";
  if(k==="BB_SPECIAL") return "特殊ブロック（効果付き）あり";
  return k;
}
function blockGoalHuman(k){
  if(k==="BB_ALL")   return "全消しでクリア";
  if(k==="BB_TIME")  return "タイムアタック（制限時間）";
  if(k==="BB_COMBO") return "コンボ重視（倍率UP/途切れでリセット）";
  return k;
}

function stepAnswered(step){ return !!state[step.key]; }
function readyAll(){
  if(!state.style) return false;
  if(state.style === "SIDE_SCROLL"){
    return !!(state.ss_move && state.ss_fire && state.ss_goal);
  }
  return !!(state.bb_control && state.bb_bricks && state.bb_goal);
}

/* =========================
 *  prompt
 * ========================= */
function buildPrompt(){
  const dot = state.dotPlayer
    ? [
        "【プレイヤー表示（ドット絵あり：ON）】",
        "- プレイヤーは 20×20 のドット絵（モノクロ）で表示すること",
        "- 表示は必ず drawBitmap() 関数を使用すること（Adafruit_GFX系の drawBitmap を想定）",
        "- 20×20のビットマップ配列（PROGMEM）をコード内に用意し、それを描画してプレイヤーを表現すること",
        ""
      ]
    : [
        "【プレイヤー表示（ドット絵あり：OFF）】",
        "- プレイヤーは矩形や簡単な図形でOK（描画負荷を軽く）",
        ""
      ];

  const header = [
    "あなたはArduino Nano（ATmega328P）のスケッチ作成者です。",
    "指定ハードで動作する「シューティングゲーム」を新規に1本作ってください。",
    "フルコードで提示してください。",
    "",
    "【ハード（固定）】",
    "- Arduino Nano（ATmega328P）",
    "- OLED（SSD1306 128x64 を前提に書く。もし別ライブラリでも差し替えやすいよう描画は関数化）",
    "- タクトスイッチ：D5, D6（INPUT_PULLUP前提。押下=LOW）",
    "- ブザー：D9",
    "",
    "【重要：ブザー】",
    "- ブザーはノンブロッキングで鳴らすこと（delayで鳴らさない）",
    "- tone()を使う場合でもゲームループを止めずに制御すること（多重発音防止も考慮）",
    "",
    "【背景（固定）】",
    "- ゲームの背景は白にすること（毎フレーム clearDisplay 相当で消して、白地に黒/青などで描画する想定）",
    "",
    ...dot,
    "【共通ルール】",
    "- delay禁止（ノンブロッキング）",
    "- millis()ベースのゲームループ",
    "- 2ボタンで成立する操作にする（D5/D6）",
    "",
  ];

  let spec = [];
  if(state.style === "SIDE_SCROLL"){
    spec = [
      `【ゲーム形】${styleHuman(state.style)}`,
      `- 自機の動き：${sideMoveHuman(state.ss_move)}`,
      `- ショット：${sideFireHuman(state.ss_fire)}`,
      `- ゴール：${sideGoalHuman(state.ss_goal)}`,
      "",
      "【横スク：最低限入れてほしい要素】",
      "- 右から敵/障害が流れてくる（速度・出現間隔は段階的に変化してOK）",
      "- 当たり判定（自機 vs 敵/障害、弾 vs 敵）",
      "- スコア計算（撃破/生存などゴールに整合）",
      "- タイトル画面→プレイ→結果→リトライの状態遷移",
      "",
      "【音（D9）】",
      "- ショット音（D6押下時）",
      "- ヒット音（敵撃破時）",
      "- ミス音（被弾/接触時）",
      "- クリア音（クリア時）",
    ];
  }else{
    spec = [
      `【ゲーム形】${styleHuman(state.style)}`,
      `- 操作方式：${blockControlHuman(state.bb_control)}`,
      `- ブロック：${blockBricksHuman(state.bb_bricks)}`,
      `- ゴール：${blockGoalHuman(state.bb_goal)}`,
      "",
      "【ブロック：最低限入れてほしい要素】",
      "- 画面上にブロック配置（行列）",
      "- 弾（上方向）とブロックの衝突→破壊/耐久減少/効果発動",
      "- スコア計算（コンボ/倍率などゴールに整合）",
      "- タイトル画面→プレイ→結果→リトライの状態遷移",
      "",
      "【音（D9）】",
      "- ショット音（D6押下時、または自動連射の発射時）",
      "- 破壊音（ブロック破壊時）",
      "- ミス音（失敗条件がある場合）",
      "- クリア音（クリア時）",
    ];
  }

  const footer = [
    "",
    "【出力】",
    "1) 仕様の要約（短く）",
    "2) フルコード（Arduino IDEに貼ってコンパイルできる形）",
    "",
    "【実装指針】",
    "- 描画は drawTitle()/drawGame()/drawResult() などに分ける",
    "- 入力は edge検出（押した瞬間）と長押し判定を実装",
    "- 音は beepStart(freq, ms) のような関数+updateBeep()でノンブロッキングにする",
  ];

  return [...header, ...spec, ...footer].join("\n");
}

/* =========================
 *  状態
 * ========================= */
function invalidatePrompt(){
  promptReady = false;
  lastPrompt = "";
  $("#askBtn").disabled = true;
  $("#copyBtn").disabled = true;
}
function setStatus(msg){ $("#status").textContent = msg || ""; }

function clearStyleDependent(){
  state.ss_move = "";
  state.ss_fire = "";
  state.ss_goal = "";
  state.bb_control = "";
  state.bb_bricks = "";
  state.bb_goal = "";
}

function finalizePrompt(){
  if(!readyAll()){
    alert("さいごまで えらんでね");
    return;
  }
  lastPrompt = buildPrompt();
  $("#out").value = lastPrompt;
  $("#outBox").scrollIntoView({behavior:"smooth", block:"start"});
  setStatus("できあがり！");
  promptReady = true;
  $("#askBtn").disabled = false;
  $("#copyBtn").disabled = false;
}

/* =========================
 *  コピー
 * ========================= */
async function copyPrompt(){
  const text = $("#out").value || "";
  if(!text.trim()){
    alert("まだプロンプトがありません（できあがり を押してね）");
    return;
  }
  try{
    if(navigator.clipboard && window.isSecureContext){
      await navigator.clipboard.writeText(text);
    }else{
      const ta = $("#out");
      ta.focus();
      ta.select();
      document.execCommand("copy");
      ta.setSelectionRange(0,0);
    }
    setStatus("コピーしました！");
    alert("コピーしました！");
  }catch(e){
    setStatus("コピー失敗: " + e);
    alert("コピー失敗: " + e);
  }
}
$("#copyBtn").onclick = ()=>{ copyPrompt(); };

/* ★追加：ドット絵ありチェックの変更でプロンプト無効化/更新 */
$("#dotPlayer").addEventListener("change", ()=>{
  state.dotPlayer = $("#dotPlayer").checked;
  // 既に出力済みなら内容を再生成して反映（※できあがり済みなら即反映）
  if($("#out").value.trim()){
    $("#out").value = buildPrompt();
    lastPrompt = $("#out").value;
  }
  // まだ「できあがり」前なら無効化だけ（仕様が変わるので）
  if(!promptReady){
    invalidatePrompt();
  }
});

/* =========================
 *  デモ描画（簡易）
 * ========================= */
let rafId = 0;
let demoStart = 0;
let demos = [];

function stopDemos(){ if(rafId) cancelAnimationFrame(rafId); rafId=0; demos=[]; }
function clear(ctx, w, h){ ctx.clearRect(0,0,w,h); }

function drawLabel(ctx, text){
  ctx.save();
  ctx.font = "bold 12px system-ui, -apple-system";
  ctx.fillStyle = "#333";
  ctx.fillText(text, 8, 16);
  ctx.restore();
}

function drawShip(ctx, x, y, s){
  ctx.save();
  ctx.fillStyle = "rgba(43,124,255,0.70)";
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x-s, y+s*0.6);
  ctx.lineTo(x-s, y-s*0.6);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}
function drawBullet(ctx, x, y){
  ctx.save();
  ctx.strokeStyle = "rgba(43,124,255,0.9)";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x+18, y);
  ctx.stroke();
  ctx.restore();
}
function drawArrow(ctx, x, y, dir){
  ctx.save();
  ctx.strokeStyle = "rgba(0,0,0,0.25)";
  ctx.lineWidth = 3;
  ctx.lineCap = "round";
  ctx.beginPath();
  if(dir==="up"){
    ctx.moveTo(x, y+12); ctx.lineTo(x, y-12);
    ctx.moveTo(x, y-12); ctx.lineTo(x-6, y-4);
    ctx.moveTo(x, y-12); ctx.lineTo(x+6, y-4);
  }else if(dir==="down"){
    ctx.moveTo(x, y-12); ctx.lineTo(x, y+12);
    ctx.moveTo(x, y+12); ctx.lineTo(x-6, y+4);
    ctx.moveTo(x, y+12); ctx.lineTo(x+6, y+4);
  }else if(dir==="left"){
    ctx.moveTo(x+12, y); ctx.lineTo(x-12, y);
    ctx.moveTo(x-12, y); ctx.lineTo(x-4, y-6);
    ctx.moveTo(x-12, y); ctx.lineTo(x-4, y+6);
  }else if(dir==="right"){
    ctx.moveTo(x-12, y); ctx.lineTo(x+12, y);
    ctx.moveTo(x+12, y); ctx.lineTo(x+4, y-6);
    ctx.moveTo(x+12, y); ctx.lineTo(x+4, y+6);
  }
  ctx.stroke();
  ctx.restore();
}
function drawBlocks(ctx, x, y, cols, rows, w, h, mode){
  ctx.save();
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const xx = x + c*(w+2);
      const yy = y + r*(h+2);
      let a = 0.10;
      if(mode==="hp2" && (c+r)%3===0) a = 0.22;
      if(mode==="special" && (c+r)%4===0) a = 0.26;
      ctx.fillStyle = `rgba(0,0,0,${a})`;
      ctx.fillRect(xx,yy,w,h);

      if(mode==="hp2" && (c+r)%3===0){
        ctx.fillStyle = "rgba(43,124,255,0.35)";
        ctx.fillRect(xx+2,yy+2,w-4,h-4);
      }
      if(mode==="special" && (c+r)%4===0){
        ctx.fillStyle = "rgba(43,124,255,0.55)";
        ctx.beginPath();
        ctx.arc(xx+w/2, yy+h/2, Math.min(w,h)/4, 0, Math.PI*2);
        ctx.fill();
      }
    }
  }
  ctx.restore();
}
function drawClock(ctx, cx, cy){
  const r=16;
  ctx.save();
  ctx.strokeStyle="rgba(0,0,0,0.25)";
  ctx.lineWidth=3;
  ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx,cy-9); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+7,cy+4); ctx.stroke();
  ctx.restore();
}

function setupDemos(){
  stopDemos();
  const cvs = Array.from(document.querySelectorAll("canvas.demo"));
  demos = cvs.map(cv=>{
    const kind = cv.dataset.demo;
    const ctx = cv.getContext("2d");
    return { cv, ctx, w:cv.width, h:cv.height, kind };
  });

  demoStart = performance.now();
  const loop = (ts)=>{
    const t = (ts - demoStart) / 1000;
    for(const d of demos) drawDemo(d, t);
    rafId = requestAnimationFrame(loop);
  };
  rafId = requestAnimationFrame(loop);
}

function drawDemo(d, t){
  const {ctx,w,h,kind} = d;
  clear(ctx,w,h);
  ctx.save(); ctx.fillStyle = "#fff"; ctx.fillRect(0,0,w,h); ctx.restore();

  if(kind==="style_side"){
    drawLabel(ctx, "横スク");
    const y = h*0.55 + Math.sin(t*2)*10;
    drawShip(ctx, w*0.25, y, 12);
    const ex = w - ((t*60) % (w+40));
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.16)";
    ctx.fillRect(ex, h*0.35, 10, 10);
    ctx.fillRect(ex+12, h*0.55, 10, 10);
    ctx.restore();
    drawBullet(ctx, w*0.33, y);
    return;
  }
  if(kind==="style_block"){
    drawLabel(ctx, "ブロック");
    drawBlocks(ctx, 10, 26, 10, 3, 12, 8, "simple");
    const bx = 10 + (Math.sin(t*1.4)*0.5+0.5)*(w-40);
    ctx.save();
    ctx.fillStyle = "rgba(43,124,255,0.45)";
    ctx.fillRect(bx, h-18, 30, 6);
    ctx.restore();
    const by = h-22 - ((t*50)%(h-48));
    ctx.save();
    ctx.strokeStyle = "rgba(43,124,255,0.9)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(bx+15, by);
    ctx.lineTo(bx+15, by-10);
    ctx.stroke();
    ctx.restore();
    return;
  }

  if(kind==="ss_move_flappy"){
    drawLabel(ctx, "D5で上昇");
    drawArrow(ctx, w*0.28, h*0.50, "up");
    drawShip(ctx, w*0.55, h*0.55 + Math.sin(t*2)*10, 12);
    return;
  }
  if(kind==="ss_move_step"){
    drawLabel(ctx, "上下1マス");
    drawArrow(ctx, w*0.28, h*0.42, "up");
    drawArrow(ctx, w*0.28, h*0.62, "down");
    drawShip(ctx, w*0.55, h*0.55 + ((Math.floor(t*2)%2)?-10:10), 12);
    return;
  }

  if(kind==="ss_fire_tap"){
    drawLabel(ctx, "1発");
    drawShip(ctx, w*0.30, h*0.55, 12);
    drawBullet(ctx, w*0.38, h*0.55);
    return;
  }
  if(kind==="ss_fire_hold"){
    drawLabel(ctx, "連射");
    drawShip(ctx, w*0.26, h*0.55, 12);
    for(let i=0;i<3;i++) drawBullet(ctx, w*(0.34 + i*0.12), h*0.55 + (i%2?6:-6));
    return;
  }

  if(kind==="ss_goal_time"){
    drawLabel(ctx, "時間");
    drawClock(ctx, w*0.55, h*0.55);
    return;
  }
  if(kind==="ss_goal_score"){
    drawLabel(ctx, "スコア");
    ctx.save();
    ctx.fillStyle="rgba(43,124,255,0.35)";
    ctx.fillRect(w*0.30, h*0.45, w*0.45, 20);
    ctx.fillStyle="#1b2a3a";
    ctx.font="bold 18px system-ui,-apple-system";
    ctx.fillText("999", w*0.42, h*0.61);
    ctx.restore();
    return;
  }
  if(kind==="ss_goal_boss"){
    drawLabel(ctx, "ボス");
    ctx.save();
    ctx.fillStyle="rgba(0,0,0,0.16)";
    ctx.fillRect(w*0.55, h*0.38, 30, 30);
    ctx.fillStyle="rgba(43,124,255,0.55)";
    ctx.fillRect(w*0.35, h*0.52, 22, 6);
    ctx.restore();
    return;
  }

  if(kind==="bb_ctrl_lr_auto"){
    drawLabel(ctx, "左右+自動");
    drawArrow(ctx, w*0.35, h*0.55, "left");
    drawArrow(ctx, w*0.60, h*0.55, "right");
    ctx.save();
    ctx.strokeStyle="rgba(43,124,255,0.9)";
    ctx.lineWidth=3;
    ctx.beginPath(); ctx.moveTo(w*0.50, h*0.70); ctx.lineTo(w*0.50, h*0.40); ctx.stroke();
    ctx.restore();
    return;
  }
  if(kind==="bb_ctrl_toggle_shot"){
    drawLabel(ctx, "反転+撃つ");
    drawArrow(ctx, w*0.40, h*0.55, "left");
    drawArrow(ctx, w*0.58, h*0.55, "right");
    ctx.save();
    ctx.fillStyle="rgba(43,124,255,0.55)";
    ctx.beginPath(); ctx.arc(w*0.50, h*0.38, 6, 0, Math.PI*2); ctx.fill();
    ctx.restore();
    return;
  }

  if(kind==="bb_brk_simple"){
    drawLabel(ctx, "1発");
    drawBlocks(ctx, 14, 26, 9, 3, 13, 8, "simple");
    return;
  }
  if(kind==="bb_brk_hp2"){
    drawLabel(ctx, "2発");
    drawBlocks(ctx, 14, 26, 9, 3, 13, 8, "hp2");
    return;
  }
  if(kind==="bb_brk_special"){
    drawLabel(ctx, "特殊");
    drawBlocks(ctx, 14, 26, 9, 3, 13, 8, "special");
    return;
  }

  if(kind==="bb_goal_all"){
    drawLabel(ctx, "全消し");
    drawBlocks(ctx, 20, 30, 7, 3, 14, 8, "simple");
    return;
  }
  if(kind==="bb_goal_time"){
    drawLabel(ctx, "時間");
    drawClock(ctx, w*0.55, h*0.55);
    return;
  }
  if(kind==="bb_goal_combo"){
    drawLabel(ctx, "コンボ");
    ctx.save();
    ctx.fillStyle="rgba(43,124,255,0.35)";
    ctx.fillRect(18, h*0.48, w-36, 16);
    ctx.fillStyle="#1b2a3a";
    ctx.font="bold 14px system-ui,-apple-system";
    ctx.fillText("x5", 24, h*0.63);
    ctx.restore();
    return;
  }
}

/* =========================
 *  UI
 * ========================= */
let idx = 0;

function render(){
  const steps = getSteps();
  if(idx >= steps.length) idx = steps.length - 1;

  const s = steps[idx];
  $("#prog").textContent = `${idx+1} / ${steps.length}`;
  $("#qTitle").textContent = s.title;
  $("#qDesc").innerHTML = s.desc;

  const cur = state[s.key];
  const box = $("#opts");
  box.innerHTML = "";

  s.options.forEach(o=>{
    const el = document.createElement("div");
    el.className = "opt" + (cur===o.k ? " sel" : "");
    el.innerHTML = `
      <div class="demoBox">
        <canvas class="demo" width="160" height="76" data-demo="${o.demo}"></canvas>
      </div>
      <div class="textBox">
        <div class="optMain">${o.label}</div>
        <div class="optSub">${o.sub}</div>
      </div>
    `;
    el.onclick = ()=>{
      if(s.key === "style" && state.style !== o.k){
        state.style = o.k;
        clearStyleDependent();
        idx = 0;
      }else{
        state[s.key] = o.k;
      }
      invalidatePrompt();
      render();
    };
    box.appendChild(el);
  });

  $("#backBtn").style.display = (idx===0) ? "none" : "";
  $("#nextBtn").style.display = (idx===steps.length-1) ? "none" : "";
  $("#doneBtn").style.display = (idx===steps.length-1) ? "" : "none";

  $("#nextBtn").disabled = !stepAnswered(s);
  $("#doneBtn").disabled = !(idx===steps.length-1 && readyAll());
  $("#askBtn").disabled = !promptReady;

  setupDemos();
}
render();

/* =========================
 *  操作
 * ========================= */
$("#backBtn").onclick = ()=>{ if(idx>0){ idx--; render(); } };
$("#nextBtn").onclick = ()=>{
  const steps = getSteps();
  const s = steps[idx];
  if(!stepAnswered(s)) return;
  if(idx < steps.length-1){ idx++; render(); }
};
$("#resetBtn").onclick = ()=>{
  if(!confirm("やりなおしますか？")) return;
  state.style="";
  clearStyleDependent();
  $("#out").value="";
  setStatus("");
  idx = 0;
  invalidatePrompt();
  render();
};

$("#doneBtn").onclick = ()=>{ finalizePrompt(); };

/* =========================
 *  PC送信
 * ========================= */
async function sendToPC(text){
  const url = getPCUrl();
  if(!url){
    throw new Error("config.js の PC_URL が読み込めていません");
  }
  const res = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "text/plain; charset=utf-8" },
    body: text
  });
  return res;
}

$("#askBtn").onclick = async ()=>{
  if(!promptReady || !lastPrompt.trim()){
    alert("まず「できあがり」をおしてね");
    return;
  }

  setStatus("送信中...");
  try{
    const res = await sendToPC(lastPrompt);
    if(res.ok){
      setStatus("PCに送信しました");
      alert("PCに送信しました");
    }else{
      setStatus("PC送信エラー: " + res.status);
      alert("PC送信エラー: " + res.status);
    }
  }catch(e){
    setStatus("PC送信に失敗: " + e);
    alert("PC送信に失敗: " + e);
  }
};
</script>

<!-- コピー/チェックのイベントは上のscript内に入れてあるのでここは不要 -->

<div id="ghPagesBox" class="hide">
  <div class="row">
    <span class="muted">共有:</span>
    <a id="ghPagesUrl" href="#" target="_blank" rel="noopener">このページ</a>
    <button id="ghCopyBtn" type="button">URLコピー</button>
    <a id="ghRepoUrl" class="hide" href="#" target="_blank" rel="noopener">GitHub</a>
  </div>
</div>
<script>
  (function(){
    // GitHub Pages / ローカル両対応：このページURLを表示＆コピー
    const box = document.getElementById("ghPagesBox");
    const aPages = document.getElementById("ghPagesUrl");
    const aRepo  = document.getElementById("ghRepoUrl");
    const btn    = document.getElementById("ghCopyBtn");

    if(!box || !aPages || !btn) return;

    const url = window.location.href;
    aPages.href = url;

    // GitHub Pages（https://...github.io...） or http(s) で開いている時だけ表示
    if (window.location.protocol === "http:" || window.location.protocol === "https:") {
      box.classList.remove("hide");
    }

    // config.js の GITHUB_REPO_URL が入ってたらGitHubリンクも出す
    try{
      if (typeof GITHUB_REPO_URL === "string" && GITHUB_REPO_URL.trim()) {
        aRepo.href = GITHUB_REPO_URL.trim();
        aRepo.classList.remove("hide");
      }
    }catch(e){}

    btn.addEventListener("click", async ()=>{
      try{
        await navigator.clipboard.writeText(url);
        btn.textContent = "コピーOK!";
        setTimeout(()=>btn.textContent="URLコピー", 1000);
      }catch(e){
        // クリップボードが使えない環境向けフォールバック
        const t = document.createElement("textarea");
        t.value = url;
        document.body.appendChild(t);
        t.select();
        document.execCommand("copy");
        document.body.removeChild(t);
        btn.textContent = "コピーOK!";
        setTimeout(()=>btn.textContent="URLコピー", 1000);
      }
    });
  })();
</script>
</body>
</html>
