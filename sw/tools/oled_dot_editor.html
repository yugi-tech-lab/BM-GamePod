<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>ドット絵ワークショップ（可変サイズ対応）</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body{
  font-family: system-ui, sans-serif;
  margin:20px;
  user-select:none;
  display:flex;             /* 全体を中央寄せ */
  flex-direction:column; /* タイトル→本体を縦に並べる */
  justify-content:center;   /* 横方向中央 */
  align-items:center;   /* 横方向中央（列レイアウト） */
}
.topRow{
  display:flex;
  gap:16px;
  align-items:flex-start;
  width:100%;
  max-width:960px;          /* セット全体の最大幅 */
}
.leftColumn{
  display:flex;
  flex-direction:column;
  gap:12px;
  flex:1 1 auto;
}
#viewCanvas{
  border:2px solid #333;
  width:95vw;
  max-width:600px;
  aspect-ratio:1/1;
  image-rendering:pixelated;
  touch-action:none;
}

/* 右パネル（全体） */
.rightPanel{
  width:280px;
  display:flex;
  flex-direction:column;
  gap:12px;
}
@media(max-width:900px){
  .topRow{
    flex-wrap:wrap;
  }
  .rightPanel{
    width:100%;
  }
}

/* カード（エリア） */
.card{
  background:#f7f7f7;
  border-radius:14px;
  padding:14px;
  border:1px solid #e5e5e5;
}
.card h2{
  font-size:16px;
  margin:0 0 10px 0;
}

/* 共通ボタン/セレクト */
.rightPanel button,
.rightPanel select,
.card button,
.card select{
  font-size:18px;
  padding:14px;
  border-radius:12px;
  border:none;
  width:100%;
  box-sizing:border-box;
}

/* 2列グリッド */
.grid2{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:10px;
}

/* シフト十字 */
.dpad{
  display:grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap:10px;
}
.dpad .spacer{
  visibility:hidden;
}

/* サイズ入力用 */
.sizeRow{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:10px;
  margin-bottom:10px;
  font-size:14px;
}
.sizeRow label{
  display:flex;
  flex-direction:column;
  gap:4px;
}
.sizeRow input{
  font-size:16px;
  padding:6px;
  border-radius:8px;
  border:1px solid #bbb;
  box-sizing:border-box;
}

/* 色 */
.btnBlack{background:#222;color:#fff;}
.btnWhite{background:#fff;color:#000;border:2px solid #999;}
.btnActive{outline:4px solid #4da3ff;}

/* 操作 */
.btnUndo{background:#cce7ff;}
.btnClear{background:#ffb3b3;}
.btnFlip{background:#ffd27f;}
.btnShift{background:#e0d4ff;}
.btnSample{background:#7ee28b;}
.btnRegister{background:#b28cff;color:#fff;}
.btnDelete{background:#ff9999;}
.btnCode{
  background:#ffe76a;
  font-size:22px;
  padding:18px;
  border-radius:14px;
  font-weight:700;
}
.btnCopy{background:#d7ffd9;}
.btnSend{background:#4da3ff;color:#fff;}

/* OLEDコードカード（キャンバスの下） */
#oledCard{
  max-width:600px;
  width:95vw;
  background:#f7f7f7;
  border-radius:14px;
  padding:14px;
  border:1px solid #e5e5e5;
}
#codeArea{
  margin-top:8px;
  display:block;
  border:1px solid #ddd;
  border-radius:12px;
  padding:12px;
  background:#fafafa;
}
#varName{
  width:100%;
  font-size:18px;
  padding:14px;
  border-radius:12px;
  border:1px solid #ccc;
  box-sizing:border-box;
  background:#eee;
  color:#666;
}
#codeText{
  width:100%;
  min-height:220px;
  font-family: ui-monospace, Menlo, Consolas, monospace;
  font-size:12px;
  white-space:pre;
  padding:10px;
  border-radius:10px;
  border:1px solid #ccc;
  box-sizing:border-box;
}
.smallNote{
  font-size:12px;
  color:#666;
  margin-top:8px;
  line-height:1.35;
}

/* サンプル：ボタン説明 */
.btnWrap{display:flex; flex-direction:column; gap:4px;}
.btnHelp{font-size:12px; color:#666; line-height:1.25; padding:0 4px;}
.helpBox{font-size:12px; color:#555; background:#fff; border:1px dashed #ccc; border-radius:12px; padding:10px; line-height:1.35; margin:10px 0;}


/* Title */
.pageTitle{
  width:100%;
  max-width:960px;
  margin: 0 auto 14px auto;
  font-size: 22px;
  font-weight: 800;
  text-align: center;
  padding: 10px 14px;
  border-radius: 14px;
  background: linear-gradient(90deg, #ffcc66, #ff99cc);
  color:#333;
  box-sizing:border-box;
}
</style>
</head>
<body>
<div class="pageTitle">OLEDドット絵エディタ</div>
<div class="topRow">
  <!-- 左：ドット絵＋OLEDコード -->
  <div class="leftColumn">
    <canvas id="viewCanvas" width="600" height="600"></canvas>

    <!-- ★ OLEDコード：ドット絵の「下」にまとめて配置 -->
    <div id="oledCard">
      <h2>OLEDコード</h2>
      <button id="codeBtn" class="btnCode">コードをつくる</button>

      <div id="codeArea">
        <input id="varName" value="PLAYER_BMP" readonly>
        <textarea id="codeText" readonly placeholder="ここにコードが出ます（上の「コードをつくる」で生成）"></textarea>

        <div style="margin-top:10px;">
          <button id="copyBtn" class="btnCopy">コピー</button>
        </div>

        <div class="smallNote" id="codeHint"></div>
      </div>
    </div>
  </div>

  <!-- 右：そうさ・サンプル -->
  <div class="rightPanel">

    <!-- 操作エリア -->
    <div class="card">
      <h2>そうさ</h2>

      <!-- サイズ指定（デフォルト 20×20） -->
      <div class="sizeRow">
        <label>
          よこ（マス）
          <input id="gridWInput" type="number" min="4" max="32" value="20">
        </label>
        <label>
          たて（マス）
          <input id="gridHInput" type="number" min="4" max="32" value="20">
        </label>
      </div>

      <div class="grid2" style="margin-bottom:10px;">
        <button id="blackBtn" class="btnBlack btnActive">くろ</button>
        <button id="whiteBtn" class="btnWhite">しろ</button>
      </div>

      <button id="undoBtn" class="btnUndo" style="margin-bottom:10px;">ひとつ もどす</button>

      <div class="grid2" style="margin-bottom:10px;">
        <button id="flipHBtn" class="btnFlip">左右はんてん</button>
        <button id="clearBtn" class="btnClear">ぜんぶけす</button>
      </div>

      <div class="dpad">
        <div class="spacer">.</div>
        <button id="shiftUpBtn" class="btnShift">↑</button>
        <div class="spacer">.</div>

        <button id="shiftLeftBtn" class="btnShift">←</button>
        <div class="spacer">.</div>
        <button id="shiftRightBtn" class="btnShift">→</button>

        <div class="spacer">.</div>
        <button id="shiftDownBtn" class="btnShift">↓</button>
        <div class="spacer">.</div>
      </div>

      <div class="smallNote">※ サイズを変えると えは きえます<br>※ シフトは はみ出たぶんは けえます</div>
    </div>

    <!-- サンプルエリア -->
    <div class="card">
      <h2>ファイル選択</h2>
      <!-- 上：読込み → 書出し -->
      <div style="display:flex; flex-direction:column; gap:10px; margin-bottom:10px;">
        <div class="btnWrap">
          <button id="importBtn" class="btnSample">リストを読込み</button>
          <div class="btnHelp">以前保存した .json を読み込んで、登録リストを更新します（今のリストは上書き）</div>
        </div>
        <div class="btnWrap">
          <button id="exportBtn" class="btnRegister">リストを書出し</button>
          <div class="btnHelp">今の登録リストを .json に書き出します（場所と名前をえらべます ※主にChrome/Edge）</div>
        </div>
      </div>
      <input id="importFileFallback" type="file" accept="application/json" style="display:none;">

      <select id="sampleSelect" style="margin-bottom:10px;">
        <option value="">登録リスト</option>
      </select>

      <div class="grid2" style="margin-bottom:10px;">
        <div class="btnWrap">
          <button id="applySampleBtn" class="btnSample">選択イラストを表示</button>
          <div class="btnHelp">登録リストで選んだイラストを、左のドット絵に表示します</div>
        </div>
        <div class="btnWrap">
          <button id="registerSampleBtn" class="btnRegister">ドット絵をリストに登録</button>
          <div class="btnHelp">今のドット絵を登録リストに追加します（同じ名前は上書き）</div>
        </div>
      </div>

      <div class="btnWrap">
        <button id="deleteSampleBtn" class="btnDelete">ドット絵をリストから削除</button>
        <div class="btnHelp">登録リストから削除します（※ファイルに残すには「リストを書出し」で保存してね）</div>
      </div>

      <div class="smallNote" id="fileStatus" style="margin-top:10px;">※ このアプリは自動保存しません。変更したら「リストを書出し」で保存してね。</div>
    </div>

  </div>
</div>

<script>
/* ===== 基本設定 ===== */
const VIEW = 600;
let gridW = 20;
let gridH = 20;
const canvas = document.getElementById("viewCanvas");
const ctx = canvas.getContext("2d");

const gridWInput = document.getElementById("gridWInput");
const gridHInput = document.getElementById("gridHInput");

let tool = "black";
let pixels = createEmptyPixels(gridW, gridH);
let history = [];

/* ===== ユーティリティ ===== */
function createEmptyPixels(w, h){
  return Array.from({length:h}, ()=>Array(w).fill(0));
}

/* ===== サンプル（ファイルでエクスポート/インポートのみ） ===== */
let samples = {};
const sampleSelect = document.getElementById("sampleSelect");
const fileStatus = document.getElementById("fileStatus");
let lastFileName = "(未選択)";

function setFileStatus(msg){
  if (!fileStatus) return;
  fileStatus.textContent = msg;
}

function refreshSampleList(){
  sampleSelect.innerHTML = '<option value="">登録リスト</option>';
  Object.keys(samples).sort((a,b)=>a.localeCompare(b,'ja')).forEach(name=>{
    const o = document.createElement("option");
    const s = samples[name];
    o.value = name;
    o.textContent = `${name} (${s.w}×${s.h})`;
    sampleSelect.appendChild(o);
  });
}
refreshSampleList();
setFileStatus('※ このアプリは自動保存しません。変更したら「リストを書出し」で保存してね。');

function buildExportObject(){
  return {
    app: "oled_dot_editor",
    schema: 2,
    exportedAt: new Date().toISOString(),
    samples: samples,
  };
}

function normalizeImported(obj){
  // 受け付ける形式：
  // A) { app, schema, samples: { name: {w,h,data} } }
  // B) { name: {w,h,data} }
  // C) { name: [[...], ...] } (20x20固定とみなす)
  const root = (obj && typeof obj === 'object') ? obj : {};
  const bag = (root.samples && typeof root.samples === 'object') ? root.samples : root;

  const out = {};
  for (const [name, val] of Object.entries(bag)){
    if (!name) continue;
    if (val && typeof val === "object" && Array.isArray(val.data)) {
      out[name] = {
        w: Math.max(4, Math.min(32, (val.w||20)|0)),
        h: Math.max(4, Math.min(32, (val.h||20)|0)),
        data: val.data
      };
    } else if (Array.isArray(val) && Array.isArray(val[0])) {
      // 旧: dataだけ
      out[name] = { w: 20, h: 20, data: val };
    }
  }
  return out;
}

/* ===== 書出し前チェック（登録リストの表示＆未登録警告） ===== */
function same2D(a, b, w, h){
  if(!Array.isArray(a) || !Array.isArray(b)) return false;
  if(a.length !== h || b.length !== h) return false;
  for(let y=0; y<h; y++){
    const ar = a[y], br = b[y];
    if(!Array.isArray(ar) || !Array.isArray(br)) return false;
    if(ar.length !== w || br.length !== w) return false;
    for(let x=0; x<w; x++){
      if((ar[x]|0) !== (br[x]|0)) return false;
    }
  }
  return true;
}

function isCurrentRegistered(){
  for(const [name, s] of Object.entries(samples)){
    if(!s || typeof s !== "object") continue;
    if((s.w|0) !== (gridW|0) || (s.h|0) !== (gridH|0)) continue;
    if(same2D(s.data, pixels, gridW, gridH)) return true;
  }
  return false;
}

function buildRegisteredListText(){
  const names = Object.keys(samples).sort((a,b)=>a.localeCompare(b,'ja'));
  let t = "登録されているドット絵一覧:\n";
  for(const n of names){
    const s = samples[n];
    if(s && typeof s === "object"){
      t += `- ${n} (${s.w}×${s.h})\n`;
    } else {
      t += `- ${n}\n`;
    }
  }
  return t;
}

function confirmBeforeExport(){
  const count = Object.keys(samples).length;
  if(count === 0){
    alert("ドット絵が登録されていません。先にドット絵を登録して下さい");
    return false;
  }
  const listText = buildRegisteredListText();

  // 現在のドット絵が登録されているかチェック
  const currentInList = isCurrentRegistered();
  if(!currentInList){
    return confirm("現在のドット絵が登録されていませんがよろしいですか？\n\n" + listText);
  }
  return confirm("次の登録リストを書出します。よろしいですか？\n\n" + listText);
}

async function importSamplesViaPicker(){
  if (!window.showOpenFilePicker) return false;
  try {
    const [handle] = await window.showOpenFilePicker({
      multiple: false,
      types: [{
        description: "JSON",
        accept: {"application/json": [".json"]}
      }]
    });
    const file = await handle.getFile();
    const text = await file.text();
    const obj = JSON.parse(text);

    samples = normalizeImported(obj);
    refreshSampleList();
    lastFileName = file.name || "(名称不明)";
    setFileStatus(`読み込み：${lastFileName}（サンプル数 ${Object.keys(samples).length}）`);
    sampleSelect.value = "";
    return true;
  } catch(e){
    if (e && e.name === 'AbortError') return true; // キャンセルは何もしない
    alert("読み込みに失敗しました：" + (e && e.message ? e.message : e));
    return true;
  }
}

async function exportSamplesViaPicker(){
  if (!window.showSaveFilePicker) return false;
  try {
    const handle = await window.showSaveFilePicker({
      suggestedName: lastFileName !== "(未選択)" ? lastFileName : "dot_samples.json",
      types: [{
        description: "JSON",
        accept: {"application/json": [".json"]}
      }]
    });

    const writable = await handle.createWritable();
    await writable.write(JSON.stringify(buildExportObject(), null, 2));
    await writable.close();

    const f = await handle.getFile();
    lastFileName = f.name || "dot_samples.json";
    setFileStatus(`書き出し：${lastFileName}（サンプル数 ${Object.keys(samples).length}）`);
    return true;
  } catch(e){
    if (e && e.name === 'AbortError') return true; // キャンセル
    alert("書き出しに失敗しました：" + (e && e.message ? e.message : e));
    return true;
  }
}

// フォールバック：File Picker非対応ブラウザ用
function importSamplesFallback(inputEl){
  const f = inputEl.files && inputEl.files[0];
  if (!f) return;
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const obj = JSON.parse(reader.result);
      samples = normalizeImported(obj);
      refreshSampleList();
      lastFileName = f.name || "(名称不明)";
      setFileStatus(`読み込み：${lastFileName}（サンプル数 ${Object.keys(samples).length}）`);
      sampleSelect.value = "";
    } catch(e){
      alert("読み込みに失敗しました：" + (e && e.message ? e.message : e));
    } finally {
      inputEl.value = "";
    }
  };
  reader.readAsText(f);
}

function exportSamplesFallback(){
  const blob = new Blob([JSON.stringify(buildExportObject(), null, 2)], {type: 'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = lastFileName !== "(未選択)" ? lastFileName : 'dot_samples.json';
  a.click();
  URL.revokeObjectURL(a.href);
  setFileStatus('※ このブラウザでは保存場所の選択ができないため、ダウンロードとして保存しました。');
}

// UI
const importBtn = document.getElementById('importBtn');
const exportBtn = document.getElementById('exportBtn');
const importFileFallback = document.getElementById('importFileFallback');

if (importBtn) {
  importBtn.onclick = async ()=>{
    const ok = await importSamplesViaPicker();
    if (!ok) {
      // フォールバック
      importFileFallback.click();
    }
  };
}
if (exportBtn) {
  exportBtn.onclick = async ()=>{
    if(!confirmBeforeExport()) return;
    const ok = await exportSamplesViaPicker();
    if (!ok) {
      exportSamplesFallback();
    }
  };
}
if (importFileFallback) {
  importFileFallback.addEventListener('change', ()=>importSamplesFallback(importFileFallback));
}

/* ===== 描画 ===== */
function draw(){
  const cellW = VIEW / gridW;
  const cellH = VIEW / gridH;

  ctx.fillStyle="#fff";
  ctx.fillRect(0,0,VIEW,VIEW);

  for(let y=0;y<gridH;y++){
    for(let x=0;x<gridW;x++){
      if(pixels[y][x]){
        ctx.fillStyle="#000";
        ctx.fillRect(x*cellW,y*cellH,cellW,cellH);
      }
    }
  }

  ctx.strokeStyle="#ccc";
  for(let i=0;i<=gridW;i++){
    ctx.beginPath();ctx.moveTo(i*cellW,0);ctx.lineTo(i*cellW,VIEW);ctx.stroke();
  }
  for(let j=0;j<=gridH;j++){
    ctx.beginPath();ctx.moveTo(0,j*cellH);ctx.lineTo(VIEW,j*cellH);ctx.stroke();
  }
}
draw();

/* ===== Undo ===== */
function saveHistory(){
  history.push(pixels.map(r=>r.slice()));
  if(history.length>30) history.shift();
}
document.getElementById("undoBtn").onclick=()=>{
  if(history.length===0) return;
  pixels = history.pop();
  draw();
};

/* ===== キャンバスサイズ変更 ===== */
function applyGridSize(newW, newH){
  newW = Math.max(4, Math.min(32, newW|0));
  newH = Math.max(4, Math.min(32, newH|0));
  if (newW === gridW && newH === gridH) return;

  if (!confirm("サイズを変えると いまの えは きえます。よろしいですか？")) {
    gridWInput.value = gridW;
    gridHInput.value = gridH;
    return;
  }

  gridW = newW;
  gridH = newH;
  gridWInput.value = gridW;
  gridHInput.value = gridH;

  pixels = createEmptyPixels(gridW, gridH);
  history = [];
  draw();
}
gridWInput.addEventListener("change", ()=>{
  applyGridSize(gridWInput.value, gridHInput.value);
});
gridHInput.addEventListener("change", ()=>{
  applyGridSize(gridWInput.value, gridHInput.value);
});

/* ===== 描く（Pointer） ===== */
let drawing=false;
canvas.addEventListener("pointerdown",e=>{
  drawing=true; saveHistory(); paint(e); e.preventDefault();
});
canvas.addEventListener("pointermove",e=>{
  if(drawing) paint(e); e.preventDefault();
});
window.addEventListener("pointerup",()=>drawing=false);
window.addEventListener("pointercancel",()=>drawing=false);

function paint(e){
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor((e.clientX-rect.left)/rect.width  * gridW);
  const y = Math.floor((e.clientY-rect.top )/rect.height * gridH);
  if(x<0||y<0||x>=gridW||y>=gridH)return;
  pixels[y][x]=(tool==="black")?1:0;
  draw();
}

/* ===== 色 ===== */
const blackBtn=document.getElementById("blackBtn");
const whiteBtn=document.getElementById("whiteBtn");
blackBtn.onclick=()=>{tool="black";blackBtn.classList.add("btnActive");whiteBtn.classList.remove("btnActive");}
whiteBtn.onclick=()=>{tool="white";whiteBtn.classList.add("btnActive");blackBtn.classList.remove("btnActive");}

/* ===== クリア ===== */
document.getElementById("clearBtn").onclick=()=>{
  saveHistory();
  pixels=createEmptyPixels(gridW, gridH);
  draw();
};

/* ===== 水平反転・シフト ===== */
function flipHorizontal(){
  saveHistory();
  const newPix=createEmptyPixels(gridW, gridH);
  for(let y=0;y<gridH;y++){
    for(let x=0;x<gridW;x++){
      newPix[y][x]=pixels[y][gridW-1-x];
    }
  }
  pixels=newPix;
  draw();
}
function shift(dx,dy){
  if(dx===0 && dy===0) return;
  saveHistory();
  const newPix=createEmptyPixels(gridW, gridH);
  for(let y=0;y<gridH;y++){
    for(let x=0;x<gridW;x++){
      const sx=x+dx;
      const sy=y+dy;
      newPix[y][x]=(sx>=0 && sx<gridW && sy>=0 && sy<gridH) ? pixels[sy][sx] : 0;
    }
  }
  pixels=newPix;
  draw();
}
document.getElementById("flipHBtn").onclick      = ()=>flipHorizontal();
document.getElementById("shiftUpBtn").onclick    = ()=>shift(0,  1);
document.getElementById("shiftDownBtn").onclick  = ()=>shift(0, -1);
document.getElementById("shiftLeftBtn").onclick  = ()=>shift(1,  0);
document.getElementById("shiftRightBtn").onclick = ()=>shift(-1, 0);

/* ===== サンプル呼び出し ===== */
document.getElementById("applySampleBtn").onclick=()=>{
  const name=sampleSelect.value;
  if(!name||!samples[name]) return;

  const s = samples[name];

  // ★ スタックチャン・クレジット表示
  const lower = name.toLowerCase();
  if (
    name.includes("スタックチャン") ||
    name.includes("ｽﾀｯｸﾁｬﾝ") ||
    lower.includes("stack-chan") ||
    lower.includes("stackchan")
  ){
    alert(
"ｽﾀｯｸﾁｬﾝはししかわ様が開発、公開している、 手乗りサイズのｽｰﾊﾟｰｶﾜｲｲコミュニケーションロボットです。\n" +
"作品ページ：https://github.com/stack-chan/stack-chan"
    );
  }

  gridW = s.w;
  gridH = s.h;
  gridWInput.value = gridW;
  gridHInput.value = gridH;

  saveHistory();
  pixels = s.data.map(r=>r.slice());
  draw();
};

/* ===== サンプル登録・削除 ===== */
document.getElementById("registerSampleBtn").onclick=()=>{
  const nameRaw=prompt("サンプルの なまえを いれてね");
  if(!nameRaw) return;
  const name=nameRaw.trim();
  if(!name) return;
  if(samples[name] && !confirm("もうあるよ。うわがきする？")) return;
  samples[name] = {
    w: gridW,
    h: gridH,
    data: pixels.map(r=>r.slice())
  };
  refreshSampleList();
  setFileStatus("※ 変更しました。必要なら『リストを書出し』で保存してね。");
  sampleSelect.value=name;
};
document.getElementById("deleteSampleBtn").onclick=()=>{
  const name=sampleSelect.value;
  if(!name) return;
  if(!confirm("けしますか？")) return;
  delete samples[name];
  refreshSampleList();
  setFileStatus("※ 変更しました。必要なら『リストを書出し』で保存してね。");
  sampleSelect.value="";
};

/* ===== OLED bitmap（Adafruit_SSD1306 + drawBitmap）===== */
function makeBitmap_Adafruit(){
  const bytesPerRow = Math.ceil(gridW/8);
  const out = [];
  for(let y=0;y<gridH;y++){
    for(let bx=0;bx<bytesPerRow;bx++){
      let b=0;
      for(let bit=0;bit<8;bit++){
        const x=bx*8+bit;
        if(x<gridW && pixels[y][x]){
          b |= (1 << (7 - bit)); // MSBが左
        }
      }
      out.push(b);
    }
  }
  return out;
}
function buildCode(){
  const name="PLAYER_BMP";
  const arr=makeBitmap_Adafruit();
  let out=`// Adafruit_SSD1306 + drawBitmap 用 (${gridW}x${gridH})\n`;
  out+=`const uint8_t ${name}[] PROGMEM = {\n  `;
  arr.forEach((b,i)=>{
    out+="0x"+b.toString(16).padStart(2,"0");
    if(i<arr.length-1) out+=", ";
    if((i+1)%12===0) out+="\n  ";
  });
  out+=`\n};\n// display.drawBitmap(x, y, ${name}, ${gridW}, ${gridH}, SSD1306_WHITE);`;
  return out;
}

/* ===== OLEDコード表示（ドット絵の下のエリアに出す） ===== */
const codeArea=document.getElementById("codeArea");
const codeText=document.getElementById("codeText");
const codeHint=document.getElementById("codeHint");
document.getElementById("codeBtn").onclick=()=>{
  codeText.value=buildCode();
  codeHint.textContent = `つかいかた例：display.drawBitmap(x, y, PLAYER_BMP, ${gridW}, ${gridH}, SSD1306_WHITE);`;
  codeArea.style.display="block";
  codeArea.scrollIntoView({behavior:"smooth", block:"nearest"});
};

/* ===== コピー ===== */
document.getElementById("copyBtn").onclick=()=>{
  codeText.focus();
  codeText.select();
  document.execCommand("copy");
  alert("コピーしました！");
};


</script>

</body>
</html>

